## FunctionalInterface<br>
1. Function
자바 8에선 Function 객체를 이용하여 익명함수를 쉽게 구현할 수 있다. new 연산자에서 추상 메소드를 Override해서 쓸 수 있지만 람다를 사용하면 코드의 가독성이 좋아지고 깔끔하게 해결된다.<br>
Function<T,R> 객체에서는 T가 입력 값 R이 결과값(리턴 타입)이다.
<pre>
// 일반적인 Function 함수
Function<String,Integer> toInt = new Function<String, Integer>() {
    @Override
    public Integer apply(String value) {
        return Integer.parseInt(value);
    }
};

// 람다를 이용한 Function 함수
final Function<String,Integer> toIntRamda = value -> Integer.parseInt(value);
</pre>

2. Consumer
Function과 비슷하지만 리턴 타입이 void이면 Consumer 객체로 만들면 된다.
<pre>
final Consumer<String> printR = new Consumer<String>() {
    @Override
    public void accept(String value) {
       System.out.println("printR:::"+value);
    }
};
       
// 람다
final Consumer<String> printR2 = value -> System.out.println("printR2:::"+value);
</pre>

3. Predicate
결과값(리턴 타입)이 항상 boolean인 Function을 말한다. Function<T,Boolean>과도 같으나 boolean이 자주 사용되고 객체가 아닌 기본자료형을 사용 할 때 자주 쓰인다.
<pre>
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6);

        Predicate<Integer> isPositive = n -> n > 0;
        List<Integer> positiveNumbers = filter(numbers, isPositive);


        Predicate<Integer> lessThan3 = n -> n < 3;
        List<Integer> lessThan3Numbers = filter(numbers, lessThan3);
    }
    
    // T로 모든 객체에 대응 할 수 있게 만들어보았다.
    private static <T> List<T> filter(List<T> list, Predicate<T> filter) {
        List<T> result = new ArrayList<>();
        for(T input : list) {
            if(filter.test(input)) {
                result.add(input);
            }
        }
        return result;
    }    
</pre>

